# 编译器运行逻辑全解

根据是否引入 **IR（Intermediate Representation，中间表示）**，编译器的架构可以分为“单遍映射型”和“多级流水线型”。无论哪种方案，其核心都是将**感性的代码**转化为**理性的指令与索引**。

------

## 方案 A：无 IR 中间表示（经典轻量级，如 Lua 1.1）

在不引入中间层的情况下，编译器必须在“理解”代码的同时完成“翻译”。

### 1. 编译期 (Compilation Phase)

- **词法分析 (Lexing)**：将源码切分为 **Tokens**。
- **语法与语义分析**：构建 AST 并检查逻辑合法性。
- **符号映射（核心逻辑）**：这是解决“编译运行分离”的关键。
  - **局部变量**：被转化为相对于栈底的**偏移量（Offset）**，名字被抛弃。
  - **全局变量**：名字被存入**常量池（Constant Pool）**，并分配一个唯一索引。
- **指令发射 (Code Generation)**：直接发射字节码。例如 `a = 10` 转化为 `PUSH 10; STORE_GLOBAL 5`（假设 `a` 的索引为 5）。

> **最终输出**：**字节码流** + **常量池/环境清单**。

### 2. 运行期 (Runtime Phase)

- **环境初始化**：虚拟机加载字节码文件，首先通过**常量池**还原“环境清单”，建立运行时的字符串查找表。
- **解释执行 (Interpretation)**：虚拟机通过程序计数器（PC）读取指令。
  - **执行逻辑**：当 VM 读到 `STORE_GLOBAL 5`，它并不知道 `a`，它只执行：`GlobalTable[5] = PopStack()`。
- **内存管理与 GC**：管理数据栈与全局容器。

------

## 方案 B：有 IR 中间表示（现代高性能，如 LuaJIT、LLVM）

引入 IR 后，编译器拥有了“思考”和“重组”代码逻辑的能力。

### 1. 编译期 (Compilation Phase)

- **前端 (Frontend)**：输出抽象的 **IR（中间表示）**（如三地址码）。
- **中端优化 (Optimizer)**：在 IR 层面进行“手术”，如：
  - **常量折叠**：`1 + 2` $\rightarrow$ `3`。
  - **死代码消除**：删除无法触达的逻辑。
- **后端 (Backend)**：**指令选择与线性化**。将优化后的 IR 映射为具体虚拟机的字节码或物理机的机器码。

### 2. 运行期 (Runtime Phase)

- **高效执行**：执行经过“提纯”的字节码。
- **JIT 编译（进阶）**：在运行时将热点字节码二次编译为物理机器码，实现原生性能。