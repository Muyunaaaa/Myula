🛠️ 后端架构方案：动态窗口式寄存器模型

---

## 1. 存储层设计：物理栈与逻辑寄存器

### • 物理数据栈 (The Global Stack)

- 后端维护一个连续的大数组 `Vec<Value>`。
- **BasePointer (BP)**：当前函数的“领地起点”。
- **TopPointer (TP)**：当前栈的“水位线”，决定了下一个函数从哪里开始。

### • 寄存器偏移映射 (Register Offsetting)

- **局部变量区 (Local Slots)**：占据 `stack[BP ... BP + N-1]`。
- **临时寄存器区 (SSA % Slots)**：占据 `stack[BP + N ...]`。
- **计算公式**：虚拟寄存器 `%n` 映射到物理地址 `stack[BP + N + n]`。  
  这样设计保证了局部变量和临时变量在物理上完全隔离，互不干扰。

---

## 2. 核心对象与资源管理

### • 静态常量池 (Static Pools)

- 在加载 IR 时，将所有立即数、字符串、全局键名存入独立池。
- 指令中只保留 `Index`，减少运行时解析开销。

### • 函数对象 (Function Object)

- 函数不再只是地址，而是一个 `FunctionInstance` 结构。
- 包含：
   - 代码原型（代码段索引）
   - Upvalue 列表（闭包引用的外部变量）

### • 数据类型 (The Value Enum)

- `Nil`
- `Number`
- `Boolean`
- `String`
- `Table`
- `Function(Arc<LFunction>)`：函数作为一等公民，可以存在寄存器里被传递。
- `Pointer(usize)`：用于后端内部处理 `AddrLocal` 或 `Upvalue` 的重定向。

---

## 3. 函数调用约定 (Calling Convention)

### • 入场 (Call 流程)

1. **参数平铺**：调用者 A 将参数依次写入 `stack[TP ...]`（当前水位线以上）。
2. **基准切换**：令 `New_BP = TP`。此时 A 刚才放参数的位置，正好变成了 B 函数的 Local 区起点。
3. **环境载入**：如果 B 是个闭包，后端从函数对象中提取 Upvalues 挂载到执行上下文中。

### • 离场 (Return 流程)

1. **结果回填**：将 B 算出的结果，拷贝回 A 预留的接收寄存器（由 Call 指令指定）。
2. **水位回退**：令 `TP = Old_BP`，直接宣告 B 占用的空间失效。
3. **物理覆盖**：无需清空数组，下一次 Call 产生的新数据会自动覆盖旧值。

---

## 4. 闭包与取地址特殊处理

### • Upvalue（逃逸分析）

- 当 `AddrLocal` 被触发或 IR 指示变量被闭包捕获时，该变量会从物理栈“逃逸”到堆上。
- **逻辑地址不变**：通过 `Value::Pointer` 机制，即使变量物理位置挪到了堆里，函数内部通过 `BP + offset` 依然能透明访问，确保指令层的一致性。

### • 内存锁逻辑

- 对于被取地址的寄存器 Slot，后端标记其为“不可复用”，直到所有引用该地址的闭包对象被 GC 回收。

---

## 5. 方案核心优势

- **寻址效率**：访问任何变量都是一次 `BP + Offset` 的加法寻址，性能极高。
- **天然支持递归**：每次递归只需推移 BP 指针，每个递归层级拥有独立的寄存器窗口，不存在变量覆盖风险。
- **前端友好**：前端无需做寄存器分配算法（Register Allocation），只需不断生成不重叠的 `%n`，后端自动完成物理映射和空间回收。
- **闭包兼容**：通过 BasePointer 偏移和 `Value::Pointer` 机制，为后续闭包和 Upvalue 的高级实现预留了无损扩展空间。
